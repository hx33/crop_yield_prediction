{"title":"Financial Time Series Models","markdown":{"yaml":{"title":"Financial Time Series Models"},"headingText":"wheat = read.csv(\"./HW4/USA_Wheat.csv\")","containsRefs":false,"markdown":"\n\n```{r, echo=FALSE,message=FALSE,warning=FALSE}\nlibrary(tidyverse)\nlibrary(forecast)\nlibrary(astsa) \nlibrary(xts)\nlibrary(tseries)\nlibrary(fpp2)\nlibrary(fma)\nlibrary(lubridate)\nlibrary(TSstudio)\nlibrary(quantmod)\nlibrary(tidyquant)\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(fGarch)\n```\n\nFor this tab, the financial time series models will be implemented, to mainly forecast the volatility of future returns, an important factor in crops trading. The data for this part of analysis is the closing returns of stocks of Bunge Limited, an American agribusiness company that mills, manufactures, and sells wheat as a main business ([Source](https://ca.finance.yahoo.com/news/3-top-wheat-stocks-buy-090000987.html)).\n\n```{r}\ngetSymbols(\"BG\", from=\"2012-01-01\", src=\"yahoo\")\n```\n\n```{r, echo=FALSE,message=FALSE,warning=FALSE}\n# wheat = wheat[,c(1,3,4,5,6,7)]\n# wheat$Yield = na.approx(wheat$Yield)\n# wheat$Food_Use = as.numeric(gsub(\",\", \"\", wheat$Food_Use))\n# wheat$Import = as.numeric(gsub(\",\", \"\", wheat$Import))\n# wheat$Export = as.numeric(gsub(\",\", \"\", wheat$Export))\n```\n\nFirst, let's look at the plot of the data and check the stationarity and volatility.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nchartSeries(BG, theme=chartTheme(\"white\"), bar.type=\"hlc\", \n            up.col=\"green\", dn.col=\"red\")\n```\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nBG_close = Ad(BG)\nreturns = diff(log(BG_close))\nchartSeries(returns, theme=chartTheme(\"white\"), bar.type=\"hlc\", \n            up.col=\"green\", dn.col=\"red\")\n```\n\nFirst, from the candlestick time series plot, there is a huge increase of the closing price of the stock since 2020, however it started to decline and is at a constant level since 2022. The closing returns does not look completely stationary, and the volatility is also hard to tell. After the differencing and log transform steps, the data seems to be stationary, while also having an increase in volatility.\n\n#### \n\n### ACF/PACF\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nggAcf(returns)\nggPacf(returns)\n```\n\nThen I will look at the ACF and PACF of the absolute returns and squared returns.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nggAcf(abs(returns))\nggAcf(returns**2)\n```\n\nIt seems that there is high correlation for the absolute and square of the returns. Therefore, fitting with just ARCH/GARCH model is not enough, and AR/ARIMA+ARCH/GARCH should be used.\n\n#### \n\n### Select AR/ARMA/ARIMA Model\n\nFirst, with AR model I want to choose the best p value.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nscores = matrix(rep(NA,4*6), nrow=6, ncol=4)\n\ni=1\nfor (p in 0:5){\n  model = Arima(returns, order=c(p,0,0), include.drift=TRUE)\n  scores[i,] = c(p, model$aic, model$bic, model$aicc)\n  i = i+1\n}\nscores = as.data.frame(scores)\ncolnames(scores) = c(\"p\",\"AIC\",\"BIC\",\"AICc\")\nscores\n```\n\nIt is obvious that p=1 is the best model.\n\n#### \n\nWith ARIMA model I want to choose the best p,d,q values.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nscores = matrix(rep(0, 6*18), nrow=18, ncol=6)\n\ni=1\nfor (p in 0:2){\n  for (d in 0:1){\n    for (q in 0:2){\n      model = Arima(returns, order=c(p,d,q), include.drift=TRUE)\n      scores[i,] = c(p,d,q,model$aic, model$bic, model$aicc)\n      i = i+1\n    }\n  }\n}\n\nscores = as.data.frame(scores)\ncolnames(scores) = c(\"p\",\"d\", \"q\",\"AIC\",\"BIC\",\"AICC\")\nknitr::kable(scores, format=\"pipe\", padding=30, digits=2)\n```\n\nIt seems that the model ARIMA(1,0,0) is the best model here, and this is the same model as the previous step. Therefore, it can be determined that the best model for now is AR(1) model.\n\n#### \n\n### Standardized Residuals Plot\n\nI will now check the standardized residuals plot of the previous selected model, to see whether further modeling is needed.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nar1 = Arima(returns, order=c(1,0,0))\nres1 = ar1$residuals\nggAcf(res1^2)\nggPacf(res1^2)\n```\n\nIt seems that there is still high correlation from the ACF and PACF of the squared residuals, therefore for further modeling I can look for appropriate ARCH or GARCH model and compare the performances.\n\n#### \n\n### AR+ARCH Model\n\nIn this step I will fit the AR model with different ARCH models and find a best one.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\narch_list = list()\ni=1\nfor (p in 1:10){\n  arch_list[[i]] = garch(ar1$res[2:(length(ar1$res)-1)], order=c(0,p), trace=F)\n  i = i+1\n}\n```\n\nLook for the best ARCH model here by comparing the AIC scores.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\naic_arch = sapply(arch_list, AIC)\nwhich(aic_arch==min(aic_arch))\n```\n\nTherefore, ARCH3 is the best one here.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\narch3 = garch(ar1$res[2:(length(ar1$res)-1)], order=c(0,3), trace=F)\nprint(aic_arch[3])\n```\n\n#### \n\n### AR+GARCH Model\n\nFor the AR+GARCH model, based on the ACF and PACF of the squared residuals of AR(1), I picked the orders of the model to be order\\[1\\]=\\[1,2\\], order\\[2\\]=\\[1,2\\].\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\ngarch11 = garchFit(formula=~garch(1,1), data=res1[2:(length(res1)-1)], trace=F)\ngarch12 = garchFit(formula=~garch(1,2), data=res1[2:(length(res1)-1)], trace=F)\ngarch21 = garchFit(formula=~garch(2,1), data=res1[2:(length(res1)-1)], trace=F)\ngarch22 = garchFit(formula=~garch(2,2), data=res1[2:(length(res1)-1)], trace=F)\n```\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\ngarch_models = c(\"garch(1,1)\", \"garch(1,2)\", \"garch(2,1)\", \"garch(2,2)\")\ngarch_AIC = c(garch11@fit$ics[1],garch12@fit$ics[1],garch21@fit$ics[1], garch22@fit$ics[1])\ngarch_BIC = c(garch11@fit$ics[2],garch12@fit$ics[2],garch21@fit$ics[2], garch22@fit$ics[2])\ngarch_SIC = c(garch11@fit$ics[3],garch12@fit$ics[3],garch21@fit$ics[3], garch22@fit$ics[3])\n\ngarchs = data.frame(garch_models, garch_AIC, garch_BIC, garch_SIC)\ngarchs\n```\n\nIt looks like that GARCH(1,2) is the best model based on the three measures. Therefore, the best model here is AR(1)+GARCH(1,2).\n\n#### \n\n### Best Model\n\nTo find the better one from AR(1)+ARCH(3) and AR(1)+GARCH(1,2), I will compare their AIC score.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nprint(paste0(\"AIC of ARCH(3) = \", aic_arch[3]))\nprint(paste0(\"AIC of GARCH(1,2) = \", garch11@fit$ics[1]*length(garch12@data)))\n```\n\nIt looks like the AIC of the AR(1)+GARCH(1,2) model is smaller. We will then look at some model diagnosis of these two models.\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nsummary(arch3)\n```\n\n```{r, echo=TRUE,message=FALSE,warning=FALSE}\nsummary(garch12)\n```\n\nLooking at the Ljung-Box test, the p-values of the tests on squared residuals are all greater than 0.05, with GARCH(1,2) has a little larger p-value, meaning that the two models both represents the residuals well. Therefore, AR(1)+GARCH(1,2) wins on lower AIC score and is the best model.\n\nThe equation of this model will be:\n\n$$\nσ_t^2 = κ+γ_1σ_{t-1}^2+α_1ε_{t−1}^2+α_2ε_{t−2}^2$$\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"financial.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":"flatly","title":"Financial Time Series Models"},"extensions":{"book":{"multiFile":true}}}}}